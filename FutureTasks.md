# Future Tasks

## UI: улучшение интерфейса

1. **Скриншот/демо для README**
   - Сделать скриншот основного окна приложения
   - Опционально: записать короткое GIF-демо рабочего процесса

2. **Улучшить визуальный стиль**
   - Подобрать более современную тему/стилизацию для PyQt6
   - Единообразные отступы, шрифты, цветовая палитра

3. **Доработать UX основного окна**
   - Добавить кнопки/команды «Читать сразу» и «Читать отложенно» в главное окно
   - Сейчас управление доступно только через системный трей — нужно дублировать в основной интерфейс

## UI: поддержка HTML-формата

Добавить отображение HTML-контента с рендерингом в text viewer. Сценарий: пользователь копирует статью из браузера (с форматированием) и вставляет в RuVox.

1. **Определение формата**
   - Детектировать HTML в буфере обмена (`text/html` MIME-тип)
   - Поддержать явный выбор формата (plain text / Markdown / HTML)

2. **Рендеринг HTML**
   - Отображать статью с сохранением форматирования: заголовки, списки, ссылки, изображения
   - Подсветка синтаксиса кода (блоки `<pre><code>`)
   - Удобный для чтения вид: ограниченная ширина текста, читаемая типографика
   - Использовать QWebEngineView (уже есть для Mermaid) или QTextBrowser

3. **Сохранение оригинального оформления**
   - Голый HTML без CSS будет выглядеть иначе, чем в браузере — нужны стили
   - Как минимум: инлайн-CSS, шрифты, цвета, отступы, подсветка кода
   - Возможно потребуются изображения, иконки, кастомные шрифты
   - **Вариант:** браузерный плагин (расширение), который собирает фрагмент страницы со всем необходимым (HTML + CSS + ресурсы) в self-contained формате и копирует в буфер / отправляет в RuVox
   - Продумать формат передачи: MHTML, single-file HTML с инлайн-стилями, или свой контейнер

4. **TTS pipeline: обработка HTML**
   - Извлекать текстовое содержимое из HTML для озвучивания
   - Пропускать навигацию, футеры, рекламу (reader mode)
   - Сохранять маппинг позиций для подсветки слов при чтении

## Транслитерация: улучшение произношения

Сейчас существует 3 независимые системы транслитерации, каждая со своей семантикой:

| Место | Тип | Назначение |
|-------|-----|------------|
| `english.py:282` `TRANSLIT_MAP` | Фонетическая (диграфы + буквы) | Произношение английских слов в тексте |
| `code.py:427` `translit_map` | Упрощённая (только 26 букв) | Произношение частей идентификаторов кода |
| `abbreviations.py:10` `LETTER_MAP` | Побуквенное произношение | Побуквенное чтение аббревиатур (API → эй пи ай) |

Объединять эти системы **не нужно** — они решают разные задачи:
- Аббревиатуры читаются побуквенно, не как слова
- Код и обычный текст могут требовать разного произношения
- Каждая система будет дорабатываться независимо

### Задачи на будущее

1. **Улучшить фонетическую транслитерацию** (`english.py:TRANSLIT_MAP`)
   - Текущая реализация — простой longest-match по диграфам
   - Можно улучшить качество произношения для распространённых английских слов
   - G2P (grapheme-to-phoneme) уже поддерживается как опция, но можно расширить покрытие

2. **Улучшить произношение идентификаторов кода** (`code.py:translit_map`)
   - Сейчас только посимвольная транслитерация для неизвестных частей
   - Можно добавить больше слов в `CODE_WORDS` или улучшить fallback

3. **Расширить словарь аббревиатур** (`abbreviations.py:LETTER_MAP`)
   - Добавить больше специальных случаев (аббревиатуры, которые читаются как слова: NASA, SCRUM и т.д.)
   - Улучшить обработку смешанных форматов (JSON5, ES2024 и т.д.)
